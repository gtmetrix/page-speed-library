// Copyright 2009 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "pagespeed/rules/enable_gzip_compression.h"

#include <string>

#include "base/logging.h"
#include "pagespeed/core/resource.h"
#include "pagespeed/core/resource_util.h"
#include "pagespeed/core/result_provider.h"
#include "pagespeed/core/rule_input.h"
#include "pagespeed/l10n/l10n.h"
#include "pagespeed/proto/pagespeed_output.pb.h"

namespace {

// Minimum number of bytes before it's typically a win to apply gzip
// to a resource. Below this size, the cost of gzip overhead typically
// outweighs the benefits of gzip compression (i.e. the compressed
// resource is larger than the uncompressed resource).
const size_t kMinGzipSize = 150;

}  // namespace

namespace pagespeed {

namespace rules {

namespace {

class GzipMinifier : public Minifier {
 public:
  GzipMinifier() {}

  // Minifier interface:
  virtual const char* name() const;
  virtual UserFacingString header_format() const;
  virtual UserFacingString body_format() const;
  virtual UserFacingString child_format() const;
  virtual UserFacingString child_format_post_gzip() const;
  virtual const char* additional_info_url() const;
  virtual const MinifierOutput* Minify(const Resource& resource,
                                       const RuleInput& input) const;

 private:
  bool IsViolation(const Resource& resource) const;

  DISALLOW_COPY_AND_ASSIGN(GzipMinifier);
};

const char* GzipMinifier::name() const {
  return "EnableGzipCompression";
}

UserFacingString GzipMinifier::header_format() const {
  // TRANSLATOR: The name of a Page Speed rule that tells webmasters to enable
  // gzip compression on their servers (i.e. enable compressing the web content
  // before it is sent to clients).  This appears in a list of rule names
  // generated by Page Speed, telling webmasters which rules they broke in their
  // website.
  return _("Enable compression");
}

UserFacingString GzipMinifier::body_format() const {
  // TRANSLATOR: Descriptive header for a list of URLs that were
  // served uncompressed, in violation of the EnableGzipCompression
  // rule.  It tells the webmaster that compressing all of those
  // resources could reduce the amount of data transferred (which
  // would speed up the site). It is followed by a list of
  // uncompressed resource URLs. The text between BEGIN_LINK and
  // END_LINK will link to a document providing additional
  // information. The "SIZE_IN_BYTES" placeholder will be replaced by
  // the absolute number of bytes or kilobytes that can be saved
  // (e.g. "5 bytes" or "23.2KiB"). The "PERCENTAGE" placeholder will
  // be replaced by the percent savings (e.g. "50%").
  return _("%(BEGIN_LINK)sEnable compression%(END_LINK)s for the following "
           "resources to reduce their transfer size by "
           "%(SIZE_IN_BYTES)s (%(PERCENTAGE)s reduction).");
}

const char* GzipMinifier::additional_info_url() const {
  return "https://developers.google.com/speed/docs/insights/EnableCompression";
}

UserFacingString GzipMinifier::child_format() const {
  // TRANSLATOR: Description of a single resource that was served uncompressed,
  // in violation of the EnableGzipCompression rule.  It gives the URL of the
  // resource, as well as the amount of data that would be saved by
  // compressing.  It appears in a list of all the uncompressed resources on a
  // site.  The "SIZE_IN_BYTES" placeholder will be replaced by the absolute
  // number of bytes or kilobytes that can be saved (e.g. "5 bytes" or
  // "23.2KiB"). The "PERCENTAGE" placeholder will be replaced by the percent
  // savings (e.g. "50%").
  return _("Compressing %(URL)s could save %(SIZE_IN_BYTES)s "
           "(%(PERCENTAGE)s reduction).");
}

UserFacingString GzipMinifier::child_format_post_gzip() const {
  // This method should never be called for this rule -- it is only called for
  // resources that were served compressed, and if the resource were
  // compressed, this rule wouldn't be giving a violation!
  DCHECK(false);
  return not_localized("%(URL)s %(SIZE_IN_BYTES)s %(PERCENTAGE)s");
}

const MinifierOutput* GzipMinifier::Minify(const Resource& resource,
                                           const RuleInput& input) const {
  if (!IsViolation(resource)) {
    return MinifierOutput::CannotBeMinified();
  }

  int compressed_size;
  if (!input.GetCompressedResponseBodySize(resource, &compressed_size)) {
    LOG(ERROR) << "GetCompressedResponseBodySize failed for resource: "
               << resource.GetRequestUrl();
    return MinifierOutput::Error();
  }

  return MinifierOutput::PlainMinifiedSize(compressed_size);
}

bool GzipMinifier::IsViolation(const Resource& resource) const {
  return (!resource_util::IsCompressedResource(resource) &&
          resource_util::IsCompressibleResource(resource) &&
          resource.GetResponseBody().size() >= kMinGzipSize);
}

class EnableCompressionScoreComputer : public CostBasedScoreComputer {
 public:
  EnableCompressionScoreComputer(const RuleResults* results,
                                 int64 max_possible_cost);
  virtual ~EnableCompressionScoreComputer();

 protected:
  virtual int64 ComputeCost();

 private:
  const RuleResults* const results_;
};

EnableCompressionScoreComputer::EnableCompressionScoreComputer(
    const RuleResults* results, int64 max_possible_cost)
    : CostBasedScoreComputer(max_possible_cost),
      results_(results) {
}

EnableCompressionScoreComputer::~EnableCompressionScoreComputer() {}

int64 EnableCompressionScoreComputer::ComputeCost() {
  int64 total_cost = 0;
  for (int idx = 0, end = results_->results_size(); idx < end; ++idx) {
    const Result& result = results_->results(idx);
    total_cost += result.original_response_bytes();
  }

  return total_cost;
}

}  // namespace

EnableGzipCompression::EnableGzipCompression()
    : MinifyRule(new GzipMinifier()) {}

int EnableGzipCompression::ComputeScore(const InputInformation& input_info,
                                        const RuleResults& results) {
  EnableCompressionScoreComputer score_computer(
      &results, resource_util::ComputeCompressibleResponseBytes(input_info));
  return score_computer.ComputeScore();
}

}  // namespace rules

}  // namespace pagespeed
